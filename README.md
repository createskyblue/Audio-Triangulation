# 声音定位系统技术说明文档

本人利用glm4.7 + claude理解原始项目后总结的笔记，可能存在错误，仅供参考使用！
项目原始地址：https://github.com/Sam-Belliveau/Audio-Triangulation 

## 项目概述

本项目实现了一个基于 Raspberry Pi Pico 的实时声音定位系统，通过三个麦克风阵列，利用**到达时间差（TDOA）**技术实现声源位置的精确识别与可视化。

**技术特点：**
- 采样率：50 kHz
- 定位算法：互相关 + 双曲线定位
- 实时热图显示：VGA 输出
- 延迟平均：指数平滑滤波

---

## 目录

1. [核心数学原理](#核心数学原理)
   - [双曲线的几何定义](#双曲线的几何定义)
   - [双曲线定位的局限性](#双曲线定位的局限性)
   - [球面交汇与双曲线交汇的本质区别](#球面交汇与双曲线交汇的本质区别)
   - [互相关算法详解](#互相关算法详解)
   - [位置评分机制](#位置评分机制)
   - [二维与三维网格搜索](#二维与三维网格搜索)
2. [系统工作流程](#系统工作流程)
3. [关键代码实现](#关键代码实现)
4. [性能参数](#性能参数)

---

## 核心数学原理

### 双曲线的几何定义

#### 什么是双曲线？

**双曲线**是平面上到两个定点（称为**焦点**）的距离之差的绝对值为常数的所有点的集合。

**数学定义：**

```
设两个焦点为 F₁ 和 F₂
对于双曲线上任意一点 P：
|PF₁ - PF₂| = 2a （常数）

其中：
- PF₁ = 点 P 到焦点 F₁ 的距离
- PF₂ = 点 P 到焦点 F₂ 的距离
- 2a = 距离差的绝对值
```

#### 几何可视化

```
                    F₁ (麦克风A)
                       •
                      /|\
                     / | \
                    /  |  \
                   /   |   \
              ____/    |h   \____
             /     /   |   \     \
            /    /     •     \    \
           /   /   (声源 P)    \   \
          /  /     /     \     \  \
         / /     /       \     \ \
        / /     /         \     \ \
       F₂•-----/-----------\-----•F₃
    (麦克风B)              (麦克风C)
```

**关键洞察：**

当声音从点 P 发出时：
- 声音到达 F₁ 和 F₂ 的时间不同
- 时间差 = 距离差 / 声速
- **距离差固定 → P 在某条双曲线上**

#### 双曲线在声音定位中的应用

对于三个麦克风阵列（A、B、C）：

| 双曲线 | 焦点 | 距离差 | 几何意义 |
|--------|------|--------|----------|
| H₁ | A, B | |dA - dB| | 声源可能在的曲线 1 |
| H₂ | A, C | |dA - dC| | 声源可能在的曲线 2 |
| H₃ | B, C | |dB - dC| | 声源可能在的曲线 3 |

**定位原理：**
- 三条双曲线理论上应该交汇于一点
- 交点位置 = 声源的真实位置

**代码实现位置：** [vga_heatmap.h:62-74](src/components/vga/vga_heatmap.h#L62-L74)

```c
// 计算网格上每个点到三个麦克风的距离
float dA = hypot3f(z_m, x_m - mic_a_location.x, y_m - mic_a_location.y);
float dB = hypot3f(z_m, x_m - mic_b_location.x, y_m - mic_b_location.y);
float dC = hypot3f(z_m, x_m - mic_c_location.x, y_m - mic_c_location.y);

// 转换为时间差（秒）
float dt_ab = (dB - dA) / SPEED_OF_SOUND_MPS;
float dt_ac = (dC - dA) / SPEED_OF_SOUND_MPS;
float dt_bc = (dC - dB) / SPEED_OF_SOUND_MPS;

// 转换为样本延迟
int s_ab = (int)roundf(dt_ab * SAMPLE_RATE_HZ);
```

#### 双曲线的两支问题

**关键特性：双曲线有两个分支**

```
              上支（一支）
            .     '  .
          .   '        '   .
        .  '    声源P₁     '  .
       .  '                  '  .
      .  '                    '  .
     F₁•----------•-----------•F₂
      .  '                    '  .
       .  '                  '  .
        .  '    声源P₂     '  .
          .  '        '  .
            '     .     '
              下支（另一支）

对于 |PF₁ - PF₂| = 常数：
P₁ 和 P₂ 都满足条件！
```

**这导致的歧义：**
- 距离差为 +5cm 的点，可能在双曲线的上支
- 距离差为 -5cm 的点，可能在双曲线的下支
- 但 |+5cm| = |-5cm| = 5cm，它们满足同一个方程！

**实际影响：**
- 给定一个距离差测量值，理论上声源可能在两条曲线上
- 三条双曲线，每条两支，最多产生 2³ = 8 个理论交点
- 其中只有一个交点是真实声源位置

---

### 双曲线定位的局限性

双曲线定位虽然在理论上完美，但在实际应用中存在多个根本性的挑战。

#### 1. 对称歧义性

**问题描述：**

对于三个麦克风阵列，双曲线系统存在天然的对称性，导致可能产生多个"合法"的声源位置。

**几何表现：**

```
平面麦克风阵列（俯视图）

          C (麦克风)
         /|\
        / | \
       /  |  \
      /   |   \
     /    |h   \  ← 双曲线 H_ac 的一支
    /     |     \
   /   P₁ •      \
  /      | \      \
 A●------|---\-----●B
  \      |    \    /
   \     |     \  /
    \    |      \/
     \   |     P₂•  ← 对称位置
      \  |     / \
       \ |    /   \
        \|   /     \
         \  /       \
          \/         \

情况1：声源在 P₁（三角形内部）
情况2：声源在 P₂（三角形外部）

两者可能产生相似的距离差！
```

**对称性的来源：**

| 对称类型 | 描述 | 影响 |
|----------|------|------|
| **平面对称** | 对于平面麦克风阵列，上下对称 | P(x,y,z) 和 P'(x,y,-z) 产生相同距离差 |
| **旋转对称** | 某些几何配置存在旋转对称性 | 多个角度位置产生相同距离差 |
| **远场对称** | 远距离声源近似为平面波 | 方向相反的远场声源难以区分 |

#### 2. 解析求解的数学困难

**问题形式：**

给定三个麦克风位置 A, B, C 和测量的距离差 Δd_AB, Δd_AC, Δd_BC，求解声源位置 (x, y, z)。

**方程组：**

```
√[(x-x_A)² + (y-y_A)² + (z-z_A)²] - √[(x-x_B)² + (y-y_B)² + (z-z_B)²] = Δd_AB
√[(x-x_A)² + (y-y_A)² + (z-z_A)²] - √[(x-x_C)² + (y-y_C)² + (z-z_C)²] = Δd_AC
√[(x-x_B)² + (y-y_B)² + (z-z_B)²] - √[(x-x_C)² + (y-y_C)² + (z-z_C)²] = Δd_BC
```

**求解困难：**

| 问题 | 说明 |
|------|------|
| **非线性** | 方程包含平方根，无法直接线性化 |
| **多解性** | 双曲线两支，可能无解、唯一解或多个解 |
| **数值不稳定** | 测量误差导致方程组无精确解 |
| **迭代依赖** | 需要牛顿法等迭代算法，依赖初值选择 |
| **计算复杂** | 包含 sqrt、三角函数，不适合嵌入式系统 |

**牛顿迭代法的局限：**

```
算法流程：
1. 给定初始猜测 (x₀, y₀, z₀)
2. 计算雅可比矩阵（一阶导数）
3. 求解线性方程组得到增量
4. 更新解
5. 重复直到收敛

问题：
• 初值敏感：可能收敛到错误的解
• 收敛性：可能不收敛或震荡
• 计算量：每次迭代需要矩阵运算
```

#### 3. 测量误差的影响

**实际情况：**

由于噪声、混响、量化误差等因素，测量的时间延迟总是有误差的。

**误差传播：**

```
真实距离差：Δd = 5.00 cm
测量值：Δd' = 5.05 cm (误差 1 mm)

双曲线方程：|PF₁ - PF₂| = 5.00 cm  →  精确交点
实际测量：  |PF₁ - PF₂| = 5.05 cm  →  无交点！

结果：三条双曲线不相交于一点
```

**几何表现：**

```
理想情况（无误差）：

    H_ab  H_ac
     \    /
      \  /
       \/  ← 精确交点
       /\

实际情况（有误差）：

    H_ab'  H_ac'
     \    /
      \  /
       X  ← 没有交点！
      / \
     /   \
    H_bc'
```

**处理方法：**

- 解析法：最小二乘拟合（计算复杂）
- 网格法：找最接近所有约束的位置（简单鲁棒）

#### 4. 高度模糊性

**问题：**

如果麦克风阵列在一个平面上（如 z=0），则对于平面对称的两个位置，距离差完全相同。

**数学说明：**

```
声源 P₁ = (x, y, +h)
声源 P₂ = (x, y, -h)

麦克风 M = (x_m, y_m, 0)

距离 PM₁ = √[(x-x_m)² + (y-y_m)² + h²]
距离 PM₂ = √[(x-x_m)² + (y-y_m)² + (-h)²]
         = √[(x-x_m)² + (y-y_m)² + h²]
         = PM₁  ← 完全相同！
```

**结论：**
- 平面麦克风阵列无法区分上下对称的位置
- 必须通过先验知识（如声源在上方）或非平面阵列来解决

#### 5. 有限范围内的模糊

**问题：**

当声源距离麦克风阵列较远时，不同位置的距离差差异变小。

**远场近似：**

```
声源距离 d >> 麦克风间距

双曲线上某点 P 的切线 ≈ 直线
→ 不同方向的角度难以精确区分
→ 角度分辨率下降
```

---

### 球面交汇与双曲线交汇的本质区别

在声音定位中，存在两种基本的几何方法：**球面交汇法**和**双曲线交汇法**（TDOA）。理解两者的根本区别对于选择正确的定位策略至关重要。

#### 核心问题：球面交汇需要绝对距离

**球面交汇法的基本思想：**

```
声源 P 发出声音，形成球面波

麦克风A接收：距离 d_A = c × t_A
麦克风B接收：距离 d_B = c × t_B
麦克风C接收：距离 d_C = c × t_C

几何意义：
- 以A为中心，半径 d_A 的球面
- 以B为中心，半径 d_B 的球面
- 以C为中心，半径 d_C 的球面

三个球面的交点 = 声源位置 P
```

**关键要求：球面的半径必须是确定的数值！**

**球面的数学定义：**

```
球面 S(P, r) = { X | PX = r }

其中：
- X = 球面上的任意点
- PX = 点 X 到中心 P 的距离
- r = 半径，必须是一个具体数值（如 5 米、10 米）
```

**为什么距离差不能直接用于球面交汇？**

假设我们只有距离差 Δd_AB = d_B - d_A = 5 cm：

```
尝试构建球面：

方法1：假设 d_A = 0
  → 球面A：半径 0（退化为中心点A）
  → 球面B：半径 5 cm
  → 球面C：半径 d_C = Δd_AC
  → 三个球面的交点：位置 P₁

方法2：假设 d_A = 10 cm
  → 球面A：半径 10 cm
  → 球面B：半径 15 cm
  → 球面C：半径 10 + Δd_AC
  → 三个球面的交点：位置 P₂ ≠ P₁

方法3：假设 d_A = 50 cm
  → 球面A：半径 50 cm
  → 球面B：半径 55 cm
  → 球面C：半径 50 + Δd_AC
  → 三个球面的交点：位置 P₃ ≠ P₁ ≠ P₂

问题：每个假设产生不同的交点！
没有唯一解！
```

**几何可视化：**

```
假设 d_A = 0:

    A(点)         B(球面半径5cm)
     •              ●
      \            /
       \          /
        \        /
         \      /
          \    /
           \  /
            \/  ← 交点 P₁

假设 d_A = 10cm:

  A(球半径10)  B(球半径15)
     ●          ●
      \        /
       \      /
        \    /
         \  /
          \/  ← 交点 P₂ ≠ P₁
```

**结论：** 没有绝对距离（或发声时刻），无法确定球面的"大小"，存在无穷多可能的位置。

#### 双曲线交汇法的巧妙之处

双曲线交汇法（TDOA）**不需要绝对距离**，直接使用距离差作为约束！

**双曲面（3D中）的数学定义：**

```
双曲面 H_AB = { P | |PB - PA| = Δd_AB }

其中：
- P = 双曲面上的任意点
- PB, PA = 点 P 到两个焦点 A、B 的距离
- Δd_AB = 距离差的绝对值（已知量！）

关键：这个定义不包含"绝对距离"
只关心"距离差是常数"
```

**为什么双曲面法有效？**

```
对于双曲面上的任意点 P：

如果 PA = 3 米，则 PB = 3.05 米
如果 PA = 5 米，则 PB = 5.05 米
如果 PA = 10 米，则 PB = 10.05 米
如果 PA = 100 米，则 PB = 100.05 米

都满足 |PB - PA| = 5 cm！

所有满足条件的点构成一个双曲面
双曲面的"形状"和"位置"是唯一确定的
不需要知道 PA, PB 的绝对值
```

**几何意义：**

```
双曲面 H_AB：|PB - PA| = 5 cm
双曲面 H_AC：|PC - PA| = 3 cm
双曲面 H_BC：|PC - PB| = 2 cm

三个双曲面的交点 = 唯一的声源位置！

不需要知道 PA, PB, PC 的绝对值
只需要知道距离差
```

#### 数学证明：为什么球面法有无穷多解

**建立方程：**

```
未知声源：P(x, y, z)
参考距离：r (未知！)
已知距离差：Δd_AB, Δd_AC

如果使用球面：
PA = r
PB = r + Δd_AB
PC = r + Δd_AC

未知数：x, y, z, r （4个未知数）
方程：3个

结果：4 - 3 = 1个自由度 → 无穷多解！
```

**如果使用双曲面：**

```
|PB - PA| = Δd_AB
|PC - PA| = Δd_AC
|PC - PB| = Δd_BC

未知数：x, y, z （3个未知数）
方程：3个

结果：3 - 3 = 0个自由度 → 唯一解（理想情况）
```

#### 直观类比

**类比1：画圆**

```
球面交汇（绝对值）：
"画一个半径为 5cm 的圆"
→ 明确、唯一 ✓

"画一个比另一个圆大 2cm 的圆"
→ 另一个圆多大？不明确 ✗
```

**类比2：等高线**

```
球面交汇：
"海拔 100 米的所有点"
→ 需要参考基准（海平面）✓

双曲线法：
"比 B 山峰高 50 米的所有点"
→ 只需要相对高度 ✓
不需要知道海拔
```

#### 两种方法的适用场景

**球面交汇法适用于：**

```
主动声源系统：
- 声纳：发出已知时刻的脉冲
- GPS：卫星发送带时间戳的信号
- 雷达：主动发射并接收回波

特点：知道"什么时候发出的"
→ 可以计算绝对距离 d = c × Δt
→ 使用球面交汇
```

**双曲线交汇法适用于：**

```
被动声源系统：
- 语音定位：不知道人什么时候说话
- 爆炸定位：突发声音，无预警
- 野生动物监测：被动监听

特点：不知道"什么时候发出的"
→ 只能测量到达时间差 ΔTDOA
→ 使用双曲线交汇
```

#### 实际应用对比

| 特性 | 球面交汇法 | 双曲线交汇法（TDOA） |
|------|-----------|---------------------|
| **需要信息** | 发声时刻或绝对距离 | 只需要到达时间差 |
| **几何约束** | 球面（有大小） | 双曲面（无大小，由距离差决定） |
| **唯一性** | 没有参考则无穷多解 | 理论上唯一解 |
| **测量难度** | 需要同步时钟 | 只需要相对时间测量 |
| **典型应用** | 声纳、GPS、雷达 | 语音定位、爆炸定位、被动监听 |
| **麦克风数量** | 最少3个（2D）、4个（3D） | 最少3个（2D）、4个（3D） |

#### 能否将距离差转换为绝对距离？

**理论上可以，但实际上困难：**

```
方法：迭代搜索
1. 假设参考距离 r₀
2. 用球面交汇计算位置 P₀
3. 检查理论距离差与测量是否匹配
4. 调整 r，重复2-3
5. 直到收敛

问题：
• 依赖初值选择
• 可能不收敛或收敛到错误解
• 计算量大（每次迭代需要解方程组）
• 这就是"牛顿迭代法"，回到解析法的困难
```

**结论：**
- 迭代方法本质上就是解析法
- 没有避开双曲线法的复杂性
- 反而增加了算法的复杂度

#### 核心洞察总结

```
球面交汇：
- 需要绝对距离 → 需要知道发声时刻
- 没有绝对值 → 球面大小不确定 → 无穷多解

双曲线交汇：
- 只需要距离差 → 不需要知道发声时刻
- 距离差直接确定双曲面形状 → 唯一解
- 更适合被动声音定位
```

**为什么距离差不能用于球面交汇？**

因为球面必须有确定的半径。距离差只能告诉我们"两个球面半径相差多少"，但不能告诉我们"每个球面半径到底是多少"。没有确定的半径，球面的大小就不确定，交点位置也就不唯一。

**为什么距离差可以用于双曲线交汇？**

因为双曲面的定义本身就是"到两点距离差为常数的点的轨迹"。距离差直接定义了双曲面的形状和位置，不需要任何额外的绝对距离信息。

这就是 TDOA（到达时间差）方法使用双曲线而不是球面的根本原因！

---

### 互相关算法详解

#### 什么是互相关？

**互相关（Cross-Correlation）** 是衡量两个信号在不同时间偏移下相似程度的数学工具。

**数学定义：**

对于离散信号 x[n] 和 y[n]，互相关函数 R_xy[k] 定义为：

```
R_xy[k] = Σ x[n] × y[n + k]
         n
```

其中：
- `k` = 时间偏移（延迟）
- `R_xy[k]` = 当 y 延迟 k 个样本时，与 x 的相似度

**物理解释：**
- R_xy[k] 的值越大 → 当 y 延迟 k 个样本时，两个信号越相似
- R_xy[k] 最大时的 k 值 → **两个信号的时间延迟**

#### 直观理解

想象有两个麦克风录制同一声音：

```
时间轴 →

麦克风A:  [安静] [安静] [声音] [声音] [声音] ...
麦克风B:  [安静] [声音] [声音] [声音] [安静] ...

问题：B 比 A 快几个样本？
```

**互相关的做法：**

1. **k = 0**（对齐）：
   ```
   A:  [安静] [安静] [声音] [声音] ...
   B:  [安静] [声音] [声音] [声音] ...
   相似度：低（波形没对上）
   ```

2. **k = -1**（B 向左移 1）：
   ```
   A:  [安静] [安静] [声音] [声音] ...
   B:  [声音] [声音] [声音] [安静] ...
   相似度：还是低
   ```

3. **k = +1**（B 向右移 1）：
   ```
   A:  [安静] [安静] [声音] [声音] ...
   B:  [安静] [安静] [声音] [声音] ...
   相似度：高！波形对上了！
   ```

**结论：时间延迟 = 1 个样本**

#### 算法实现

**代码位置：** [correlations.c:9-24](src/components/correlations.c#L9-L24)

```c
void correlations_init(struct correlations_t *corr,
                       const struct buffer_t *buf_a,
                       const struct buffer_t *buf_b) {
  power_t best_score = INT64_MIN;

  // 遍历所有可能的时间偏移
  for (int s = -MAX_SHIFT_SAMPLES; s <= MAX_SHIFT_SAMPLES; s++) {
    power_t score = 0;

    // 根据偏移量调整指针位置
    const sample_t *p = (s < 0 ? buf_a->buffer - s : buf_a->buffer);
    const sample_t *q = (s < 0 ? buf_b->buffer : buf_b->buffer + s);
    int n = BUFFER_SIZE - (s < 0 ? -s : s);

    // 计算互相关：逐点相乘再求和
    for (int i = 0; i < n; i++, p++, q++)
      score += (int32_t)(*p) * (int32_t)(*q);

    // 存储这个偏移的相似度得分
    corr->correlations[s + MAX_SHIFT_SAMPLES] = score;

    // 记录最高分及其对应的偏移
    if (score > best_score) {
      best_score = score;
      corr->best_shift = s;
    }
  }
}
```

**算法步骤：**

1. **遍历偏移**：尝试所有可能的时间偏移（从 -MAX_SHIFT_SAMPLES 到 +MAX_SHIFT_SAMPLES）

2. **信号对齐**：根据偏移量调整两个信号的起始位置

3. **计算相似度**：
   - 逐点相乘：`A[i] × B[i+s]`
   - 累加求和：`Σ A[i] × B[i+s]`
   - 相乘的性质：当两个信号同相（都为正或都为负）时，乘积为正，贡献大

4. **找出最大值**：最大得分对应的偏移量就是时间延迟

#### 为什么乘积能表示相似度？

**数学原理：**

假设两个信号：
- 当它们对齐时：相同位置的点往往同号（正×正=正，负×负=正）
- 累加和会很大

- 当它们没对齐时：符号随机，正负抵消
- 累加和接近零

**示例：**

```
对齐的情况：
A: [ 1,  2,  3, -2]
B: [ 2,  4,  6, -4]
乘积：2 + 8 + 18 + 8 = 36 （很大！）

不对齐的情况（B 向右移 1）：
A: [ 1,  2,  3, -2]
B:    [ 2,  4,  6, -4]
乘积：2 + 8 - 18 + 8 = 0 （相互抵消）
```

#### 时间延迟与距离的关系

**公式：**

```
距离差 (Δd) = 时间延迟 (Δt) × 声速 (c)

时间延迟 (Δt) = 样本偏移 (s) / 采样率 (fs)
```

**本系统的参数：**
- 采样率 `fs = 50,000 Hz`
- 声速 `c = 343 m/s`
- 1 个样本对应的距离 = `343 / 50,000 ≈ 6.86 mm`

**示例：**
如果测得 `s = 10` 个样本的延迟：
```
时间延迟 = 10 / 50,000 = 0.0002 秒 = 200 微秒
距离差 = 0.0002 × 343 = 0.0686 米 ≈ 6.86 厘米
```

---

### 位置评分机制

#### 基本思想

在获取了三对麦克风的时间延迟后，我们需要回答：
**"声源到底在哪里？"**

传统方法是解双曲线方程组，但本项目采用了更直观、鲁棒的**网格搜索法**：

1. 预先计算网格上每个点对应的理论时间延迟
2. 与实测的互相关结果对比
3. 找出匹配度最高的位置

#### 评分算法

**代码位置：** [vga_heatmap.h:48-92](src/components/vga/vga_heatmap.h#L48-L92)

**初始化阶段（预计算）：**

```c
void vga_init_heatmap() {
  for (int y = 0; y < HEIGMAP_HEIGHT; y++) {
    for (int x = 0; x < HEATMAP_WIDTH; x++) {
      // 1. 将网格坐标转换为物理坐标（米）
      float x_m = (x - POS_HALF_W) / POS_SCALE;
      float y_m = (POS_HALF_H - y) / POS_SCALE;

      // 2. 计算该点到三个麦克风的距离
      float dA = hypot3f(z_m, x_m - mic_a_location.x, y_m - mic_a_location.y);
      float dB = hypot3f(z_m, x_m - mic_b_location.x, y_m - mic_b_location.y);
      float dC = hypot3f(z_m, x_m - mic_c_location.x, y_m - mic_c_location.y);

      // 3. 计算该点应产生的时间差（转换为样本）
      float dt_ab = (dB - dA) / SPEED_OF_SOUND_MPS;
      int s_ab = (int)roundf(dt_ab * SAMPLE_RATE_HZ);

      // 4. 保存这个位置对应的样本偏移索引
      heat_idx_ab[y][x] = (uint8_t)(s_ab + MAX_SHIFT_SAMPLES);
    }
  }
}
```

**实时评分阶段：**

```c
void vga_draw_heatmap() {
  int64_t highest_L = INT64_MIN;

  // 第一步：找到所有位置中的最高分
  for (int y = 0; y < HEATMAP_HEIGHT; y++) {
    for (int x = 0; x < HEATMAP_WIDTH; x++) {
      // 获取该位置对应的理论偏移
      uint8_t idx_ab = heat_idx_ab[y][x];
      uint8_t idx_ac = heat_idx_ac[y][x];
      uint8_t idx_bc = heat_idx_bc[y][x];

      // 计算总分：三个互相关值的和
      int64_t L = corr_ab.correlations[idx_ab] +
                  corr_ac.correlations[idx_ac] +
                  corr_bc.correlations[idx_bc];

      if (L > highest_L)
        highest_L = L;
    }
  }

  // 第二步：根据分数归一化并显示热图
  int64_t t_white = (highest_L * 63) >> 6;   // ~98%
  int64_t t_green = (highest_L * 31) >> 5;   // ~97%
  int64_t t_red   = (highest_L * 15) >> 4;   // ~94%
  int64_t t_blue  = (highest_L * 7) >> 3;    // ~88%

  for (int y = 0; y < HEATMAP_HEIGHT; y++) {
    for (int x = 0; x < HEATMAP_WIDTH; x++) {
      int64_t L = corr_ab.correlations[heat_idx_ab[y][x]] +
                  corr_ac.correlations[heat_idx_ac[y][x]] +
                  corr_bc.correlations[heat_idx_bc[y][x]];

      // 根据分数分配颜色
      char c = (L >= t_white ? WHITE :
                L >= t_green ? GREEN :
                L >= t_red   ? RED :
                L >= t_blue  ? BLUE : BLACK);

      // 绘制像素
      fillRect(px, py, size, size, c);
    }
  }
}
```

#### 评分公式的含义

**总评分公式：**

```
L(x, y) = R_AB[s_ab(x,y)] + R_AC[s_ac(x,y)] + R_BC[s_bc(x,y)]
```

其中：
- `(x, y)` = 候选位置
- `s_ab(x,y)` = 如果声源在 (x,y)，A-B 应该测得的理论延迟
- `R_AB[s]` = 实测的 A-B 互相关函数在延迟 s 处的值
- `L(x,y)` = 位置 (x,y) 的总分

**物理意义：**

| 分数高 | 分数低 |
|--------|--------|
| 理论预测的延迟与实测互相关峰值一致 | 理论预测的延迟与实测互相关不匹配 |
| 该位置很可能是真实声源 | 该位置不太可能是声源 |

**为什么求和？**

三对麦克风提供独立的信息：
- A-B 告诉我们：声源在双曲线 H₁ 上
- A-C 告诉我们：声源在双曲线 H₂ 上
- B-C 告诉我们：声源在双曲线 H₃ 上

**完美的声源位置**应该同时满足三个约束，因此三个互相关值都应该很高。

#### 高斯平滑处理

**代码位置：** [correlations.c:26-33](src/components/correlations.c#L26-L33)

```c
// 对互相关结果应用高斯平滑
for (int s = -MAX_SHIFT_SAMPLES; s <= MAX_SHIFT_SAMPLES; s++) {
  int diff = s - corr->best_shift;
  diff *= diff;
  const float scale = exp(-diff / 36.f);
  corr->correlations[s + MAX_SHIFT_SAMPLES] *= scale;
}
```

**作用：**
- 以最佳延迟为中心，应用高斯衰减
- 使得接近最佳值的延迟也有一定得分
- 增加系统鲁棒性，容忍轻微误差

---

### 二维与三维网格搜索

#### 为什么选择网格搜索而非解析解？

面对前述双曲线定位的诸多局限性，本项目采用**网格搜索法**作为定位策略。这是一种用"计算换复杂度"的工程思路。

**核心思想：**

不直接求解复杂的非线性方程组，而是：
1. 将可能的空间离散化为网格
2. 计算每个网格点的"匹配度"
3. 选择匹配度最高的位置

**优势对比：**

| 方法 | 复杂度 | 鲁棒性 | 实现难度 | 嵌入式适用性 |
|------|--------|--------|----------|--------------|
| **解析解（牛顿法）** | 高 | 低 | 高 | 差 |
| **网格搜索** | 低 | 高 | 低 | 优 |

#### 穷举搜索与迭代优化的本质区别

在讨论定位算法时，容易混淆两种不同的"迭代"概念：**穷举搜索**（网格搜索）和**迭代优化**（如牛顿法）。理解两者的区别对于正确评估算法选择至关重要。

**核心问题：网格搜索是不是"迭代法"？**

从表面上看，网格搜索确实在"遍历"所有可能的候选位置，这与"迭代"的字面意思相似。但在算法理论和实际应用中，两者有本质区别。

##### 穷举搜索（网格搜索）

**基本思路：**

```
"我不知道声源在哪里，那就把所有可能的位置都试一遍"

伪代码：
for x from -2m to +2m:
    for y from -2m to +2m:
        计算位置 的匹配度
        如果 匹配度 > 当前最高分:
            记录 为最佳位置

返回：最佳位置
```

**实际代码（当前实现）：**

```c
// vga_heatmap.h:99-107
int64_t highest_L = INT64_MIN;
int best_x = 0, best_y = 0;

for (int y = 0; y < HEIGHT; y++) {
    for (int x = 0; x < WIDTH; x++) {
        // 计算这个位置的总分
        int64_t score = corr_ab.correlations[heat_idx_ab[y][x]] +
                        corr_ac.correlations[heat_idx_ac[y][x]] +
                        corr_bc.correlations[heat_idx_bc[y][x]];

        // 如果更高，更新最佳位置
        if (score > highest_L) {
            highest_L = score;
            best_x = x;
            best_y = y;
        }
    }
}

// best_x, best_y 就是答案
```

**关键特点：**

1. **系统性**：按照预定顺序（如从左到右、从上到下）检查每个候选解
2. **独立性**：每个位置的计算不依赖前一个位置的结果
3. **确定性**：相同输入总是产生相同输出
4. **全局搜索**：理论上检查整个搜索空间
5. **无收敛概念**：不需要判断"是否收敛"，只需遍历完成

**计算复杂度：**

```
完全由网格大小决定：
- 2D: 101 × 101 = 10,201 次计算
- 3D: 30 × 30 × 15 = 13,500 次计算

时间：O(N × M) 或 O(N × M × L)
其中 N, M, L 是网格维度
```

##### 迭代优化（牛顿法）

**基本思路：**

```
"我先猜一个位置，然后根据数学公式一步步逼近"

伪代码：
P = 初始猜测;

while (未收敛):
    // 计算当前估计的误差
    residual = compute_residual(P);

    // 计算如何调整（需要导数）
    delta = solve_jacobian(residual);

    // 更新估计值
    P = P + delta;

    // 检查是否收敛
    if (||delta|| < threshold):
        收敛！

return: P (如果收敛了)
```

**典型实现：**

```c
// 牛顿迭代法求解双曲线交点
x = initial_x;
y = initial_y;
z = initial_z;

for (int iter = 0; iter < MAX_ITER; iter++) {
    // 1. 计算雅可比矩阵（一阶导数）
    J[3][3] = {
        {∂f₁/∂x, ∂f₁/∂y, ∂f₁/∂z},
        {∂f₂/∂x, ∂f₂/∂y, ∂f₂/∂z},
        {∂f₃/∂x, ∂f₃/∂y, ∂f₃/∂z}
    };

    // 2. 计算残差
    residual[3] = {f₁(x,y,z), f₂(x,y,z), f₃(x,y,z)};

    // 3. 求解线性方程组 J × delta = -residual
    solve_linear_system(J, residual, delta);

    // 4. 更新估计值
    x += delta[0];
    y += delta[1];
    z += delta[2];

    // 5. 检查收敛
    if (norm(delta) < EPSILON) break;
}

// x, y, z 是答案（如果收敛）
```

**关键特点：**

1. **依赖初值**：必须提供一个初始猜测 P₀
2. **逐步改进**：每次迭代基于前一次的结果进行调整
3. **收敛性**：需要"收敛"（变化小于阈值）才停止
4. **局部搜索**：可能陷入局部最优
5. **不确定性**：可能不收敛或收敛到错误解

**计算复杂度：**

```
取决于迭代次数（不可控）：
- 最理想情况：几次迭代
- 最坏情况：永不收敛
- 平均情况：10-100 次迭代

每次迭代：O(n³) (求解线性方程组)
总时间：不确定！
```

##### 本质区别对比

| 特性 | 穷举搜索（网格法） | 迭代优化（牛顿法） |
|------|-------------------|-------------------|
| **本质** | 系统性检查所有候选解 | 从单点逐步改进 |
| **"迭代"含义** | 重复的独立计算 | 依赖前次的增量更新 |
| **初值要求** | ✗ 不需要 | ✓ 必须提供 |
| **收敛判断** | ✗ 不存在（遍历完成即停止） | ✓ 需要判断是否收敛 |
| **结果保证** | ✓ 一定有结果（最高分） | ✗ 可能不收敛 |
| **局部最优** | ✗ 不会（全局搜索） | ✓ 可能陷入 |
| **计算量** | 可控（网格大小） | 不可控（迭代次数） |
| **实现难度** | 低（简单的循环） | 高（求导、矩阵运算） |
| **确定性** | 100%（相同输入→相同输出） | 低（依赖初值） |
| **并行化** | 天然支持 | 困难 |

##### 直观类比

**穷举搜索：**

```
就像在房间里找人：

方法：把房间分成1m×1m的网格
      在每个格子处站一个人看
      记录谁听到的声音最清楚

特点：
- 系统性强（不遗漏任何格子）
- 一定能找到（或确定不存在）
- 工作量大但可预测
- 不需要任何先验猜测
```

**迭代优化：**

```
就像在雾中找出口：

方法：从当前位置出发
      感知哪个方向声音更清晰
      往那个方向走几步
      再感知，再调整...
      直到找到或走不动

特点：
- 依赖起始位置
- 可能陷入局部最优（某个假出口）
- 可能很快找到（运气好）
- 可能永远找不到（运气差）
```

##### 为什么网格搜索更适合？

在你的声音定位项目中，选择网格搜索而非迭代优化的原因：

**1. 可靠性**

```
穷举搜索：
- 100% 会找到结果
- 不会"失败"
- 不会陷入死循环

迭代优化：
- 可能不收敛
- 可能收敛到错误位置
- 需要处理失败情况
```

**2. 简单性**

```
穷举搜索：
for (y) {
    for (x) {
        score = compute_score(x, y);
        if (score > best) best = score;
    }
}

→ 10行代码，易于理解和调试

迭代优化：
需要：
- 雅可比矩阵计算
- 线性方程组求解
- 收敛判断逻辑
- 失败处理机制

→ 100+行代码，难以调试
```

**3. 性能可控**

```
穷举搜索：
- 时间：10,201 次计算 × 每次约 0.1μs = 1ms
- 可预测，可优化

迭代优化：
- 时间：10 次迭代 × 每次 100μs = 1ms（理想）
- 时间：1000 次迭代 × 每次 100μs = 100ms（最坏）
- 不可预测
```

**4. 全局最优**

```
穷举搜索：
- 检查所有候选解
- 找到的是全局最高分
- 不会错过更好的位置

迭代优化：
- 从一个起点出发
- 可能收敛到局部最优
- 取决于初值选择
```

**5. 鲁棒性**

```
穷举搜索：
- 对测量误差鲁棒
- 对多解问题鲁棒
- 不需要调参（网格大小可预先设定）

迭代优化：
- 误差大时可能不收敛
- 多解时依赖初值
- 需要调整收敛阈值、学习率等超参数
```

##### "暴力"其实很聪明

虽然网格搜索被称为"暴力搜索"（Brute Force），但在工程上这是**明智的选择**：

```
表面上：
- "暴力"遍历所有位置
- 看起来不优雅
- 计算量大

实际上：
- 预计算 + 查表 = 非常高效
- 确定性 = 适合实时系统
- 简单性 = 易于维护和调试
- 鲁棒性 = 工业级可靠性

这就是为什么网格搜索在工程实践中被广泛采用！
```

##### 关键术语澄清

在文档和讨论中，需要注意以下术语的准确使用：

| 常用术语 | 精确含义 | 本项目使用 |
|----------|----------|-----------|
| **暴力搜索** | 尝试所有可能的解 | ✓ 是 |
| **穷举搜索** | 系统性检查所有候选解 | ✓ 是（更准确） |
| **网格搜索** | 在离散网格上穷举 | ✓ 是 |
| **迭代法** | 从起点逐步改进（牛顿法等） | ✗ 不是 |
| **迭代优化** | 通过迭代优化目标函数 | ✗ 不是 |

**注意：** 本项目的代码中有 `for` 循环，这确实是"迭代"编程结构，但不是"迭代算法"（Iterative Algorithm）。前者是编程概念（重复执行），后者是算法策略（逐步逼近）。

##### 总结

**网格搜索的本质：**

```
穷举搜索：
- 离散化搜索空间
- 系统性遍历所有候选解
- 选择最佳候选
- 100% 确定性

迭代优化：
- 从单个候选解开始
- 逐步改进估计值
- 收敛到局部最优
- 不确定性
```

**为什么选择穷举搜索：**

1. ✓ 确定性：一定有结果
2. ✓ 简单性：易于实现
3. ✓ 鲁棒性：不怕多解、误差
4. ✓ 可控性：性能可预测
5. ✓ 全局性：不会陷入局部最优

**代价：**

1. ✗ 计算量大（但现代硬件够快）
2. ✗ 内存占用（但可接受）
3. ✗ 分辨率受限（但可调整）

**结论：** 在嵌入式声音定位系统中，穷举搜索的"暴力"实际上是**工程上最智慧的选择**！

---

#### 二维网格搜索（当前实现）

**设计约束：**

为了克服双曲线定位的歧义性，系统施加了两个关键的先验约束：

1. **平面约束**：假设声源在固定高度
2. **区域约束**：限制搜索在有限范围内

**搜索空间定义：**

```
物理空间：
- X 方向：-2.0m ~ +2.0m
- Y 方向：-2.0m ~ +2.0m
- Z 方向：固定在 1.2m 高度

网格参数：
- 分辨率：101 × 101 像素
- 缩放：24 像素/米
```

**算法流程：**

```
阶段1：初始化（预计算，只运行一次）

for 每个网格点 (x, y):
    1. 转换到物理坐标
       x_m = (x - 中心) / 缩放
       y_m = (y - 中心) / 缩放
       z_m = 1.2m  ← 固定高度

    2. 计算到三个麦克风的距离
       dA = √[(x_m-x_A)² + (y_m-y_A)² + z_m²]
       dB = √[(x_m-x_B)² + (y_m-y_B)² + z_m²]
       dC = √[(x_m-x_C)² + (y_m-y_C)² + z_m²]

    3. 计算理论延迟
       dt_ab = (dB - dA) / 声速
       dt_ac = (dC - dA) / 声速
       dt_bc = (dC - dB) / 声速

    4. 转换为样本偏移索引
       s_ab = round(dt_ab × 采样率)
       存储到 heat_idx_ab[y][x]

阶段2：实时评分

for 每个网格点 (x, y):
    1. 查表获取该点的理论偏移索引
       idx_ab = heat_idx_ab[y][x]

    2. 从互相关结果中查得实测分数
       score_ab = corr_ab.correlations[idx_ab]
       score_ac = corr_ac.correlations[idx_ac]
       score_bc = corr_bc.correlations[idx_bc]

    3. 计算总分
       total = score_ab + score_ac + score_bc

    4. 记录最高分位置

阶段3：可视化

- 将每个网格点的总分映射为颜色
- VGA 实时渲染热图
- 白色 = 最高分（最可能是声源）
- 黑色 = 最低分
```

**计算复杂度：**

```
预计算阶段：
- 网格点数：101 × 101 = 10,201
- 每点计算：3 次距离计算 + 几次算术运算
- 总耗时：约 1-2 ms（只运行一次）

实时评分阶段：
- 网格点数：10,201
- 每点计算：3 次数组访问 + 2 次加法
- 总耗时：< 1 ms

总计：< 3 ms，满足实时性要求
```

**内存占用：**

```
存储需求：
- 三个索引表：heat_idx_ab, heat_idx_ac, heat_idx_bc
- 每个表大小：101 × 101 × 1 字节 ≈ 10.2 KB
- 总内存占用：约 30.6 KB

在 RP2040 的 264 KB RAM 中完全可以接受
```

**如何解决歧义性：**

通过先验约束，有效排除了不可能的解：

| 歧义类型 | 解决方法 |
|----------|----------|
| 高度对称（z 和 -z） | 固定 z = 1.2m，只搜索上半空间 |
| 远场对称 | 限制搜索范围在 ±2m 内 |
| 多解问题 | 网格搜索自然选择"最匹配"的位置 |
| 测量误差导致无解 | 网格法不要求精确交点，只需最高分 |

**局限性：**

1. **高度限制**：
   - 只能定位固定高度的声源
   - 不同高度的声源会投影到 1.2m 平面，产生误差

2. **范围限制**：
   - 搜索范围外的声源无法定位
   - 显示"无明确信号"

3. **分辨率限制**：
   - 网格分辨率决定定位精度
   - 当前设置约 4cm/像素

#### 三维网格搜索（扩展思路）

**动机：**

为了克服 2D 搜索的高度限制，自然扩展到完整的 3D 空间搜索。

**搜索空间设计：**

```
物理空间：
- X 方向：-3.0m ~ +3.0m（扩大范围）
- Y 方向：-3.0m ~ +3.0m
- Z 方向：0.0m ~ +3.0m（可变高度）

网格参数（示例）：
- X 分辨率：30 格
- Y 分辨率：30 格
- Z 分辨率：15 格
- 总网格点：30 × 30 × 15 = 13,500
```

**算法扩展：**

```
初始化阶段：

for z in 0..DEPTH:
    for y in 0..HEIGHT:
        for x in 0..WIDTH:
            // 转换到 3D 物理坐标
            x_m = x_范围[0] + (x_范围[1] - x_范围[0]) × x / (WIDTH-1)
            y_m = y_范围[0] + (y_范围[1] - y_范围[0]) × y / (HEIGHT-1)
            z_m = z_范围[0] + (z_范围[1] - z_范围[0]) × z / (DEPTH-1)

            // 计算距离（完整 3D）
            dA = √[(x_m-x_A)² + (y_m-y_A)² + (z_m-z_A)²]
            dB = √[(x_m-x_B)² + (y_m-y_B)² + (z_m-z_B)²]
            dC = √[(x_m-x_C)² + (y_m-y_C)² + (z_m-z_C)²]

            // 存储到 3D 数组
            heat_idx_ab[z][y][x] = ...
```

**计算量分析：**

```
场景1：稀疏网格（快速）
- 网格：10 × 10 × 10 = 1,000 点
- 实时评分：约 0.05 ms
- 内存：约 3 KB
- 精度：较低

场景2：中等网格（平衡）
- 网格：30 × 30 × 15 = 13,500 点
- 实时评分：约 0.5 ms
- 内存：约 40 KB
- 精度：中等

场景3：精细网格（高精度）
- 网格：50 × 50 × 20 = 50,000 点
- 实时评分：约 2 ms
- 内存：约 150 KB
- 精度：高

所有场景都满足实时性要求（< 5 ms）
```

**优势：**

1. **完整定位**：
   - 可以定位任意高度的声源
   - 不再受固定高度限制

2. **扩展范围**：
   - 可以定位麦克风阵列外部的声源
   - 只需扩大搜索范围即可

3. **保持简单**：
   - 算法结构与 2D 完全相同
   - 只是多了一层循环

4. **自动处理歧义**：
   - 通过搜索范围限制排除对称解
   - 例如：z 范围设为 [0, 3]m，自动排除负 z

**可视化挑战：**

VGA 是 2D 显示设备，无法直接显示 3D 热图。可能的解决方案：

| 方案 | 描述 | 优势 | 劣势 |
|------|------|------|------|
| **最高分显示** | 只显示最高分位置 | 简单清晰 | 无全局信息 |
| **三视图** | XY、XZ、YZ 三个切片 | 完整信息 | 屏幕分割 |
| **等值面** | 3D 渲染 | 直观 | 计算量大 |
| **投影** | 3D 投影到 2D 平面 | 保留全局信息 | 损失深度信息 |

**推荐方案（最高分显示）：**

```
算法：
1. 遍历所有 3D 网格点，找到最高分位置
2. 转换回物理坐标 (x, y, z)
3. 在 VGA 上绘制：
   - 坐标系（三个轴）
   - 麦克风位置 A、B、C
   - 声源位置（用颜色标识）
   - 坐标数值显示

显示内容示例：

         Z (高度)
         ↑
         |
         |      ● Source
         |    (1.2, 0.5, 1.5)
         |
    ______|_______ Y
        ● \
      A    \
            \  ●
             B  ● C
                 \
                  \
                   X
```

**处理麦克风外部声源：**

```
问题：声源在搜索范围外怎么办？

解决：扩大搜索范围

例如：
原始范围：±2m
扩大范围：±5m

代价：
- 计算量增加：(5/2)² ≈ 6.25 倍
- 内存增加：6.25 倍

优化方案：
- 自适应网格：中心密、边缘疏
- 多分辨率：粗网格找大致区域，细网格精化
- 分层搜索：先低分辨率全局搜索，再高分辨率局部搜索
```

#### 网格搜索的进一步优化

**1. 金字塔搜索（多分辨率）**

```
思路：从粗到细，逐步精化

步骤：
1. 粗网格：20 × 20 × 10 = 4,000 点
   - 找到最高分区域

2. 中等网格：在该区域内 40 × 40 × 20 = 32,000 点
   - 精化位置

3. 细网格：在小范围内 80 × 80 × 40 = 256,000 点
   - 最终精确位置

优势：
- 粗网格快速排除大部分区域
- 计算量集中在高概率区域
- 总耗时可能小于均匀细网格
```

**2. 自适应网格**

```
思路：根据匹配度动态调整网格密度

算法：
1. 初始：均匀粗网格
2. 评分：
   - 高分区域：细分网格
   - 低分区域：保持稀疏
3. 迭代：直到满足精度要求

优势：
- 自动聚焦在高概率区域
- 避免浪费计算在低概率区域
```

**3. 并行化**

```
思路：网格搜索天然可并行

方案：
- GPU：每个线程处理一个网格点
- 多核 CPU：分块并行
- FPGA：硬件加速

适用场景：
- 高分辨率网格（100×100×50）
- 实时性要求极高
```

#### 2D 与 3D 方案对比总结

| 特性 | 2D 固定高度 | 3D 完整空间 |
|------|-------------|-------------|
| **搜索空间** | 10,000 点 | 1,000 ~ 50,000 点 |
| **内存占用** | ~30 KB | ~3 ~ 150 KB |
| **计算时间** | < 1 ms | 0.05 ~ 2 ms |
| **定位能力** | 固定高度 | 任意位置 |
| **外部声源** | 困难 | 容易（扩大范围） |
| **实现复杂度** | 低 | 中 |
| **可视化** | 简单（热图） | 需设计（3D 显示） |
| **适用场景** | 桌面应用、已知高度 | 通用定位、追踪 |

**选择建议：**

- **2D 方案**：声源高度已知或变化不大的场景（如桌面会议系统）
- **3D 方案**：需要完整空间定位的场景（如无人机追踪、室内定位）

---

## 系统工作流程

### 完整流程图

```
┌─────────────────────────────────────────────────────────────┐
│                     1. 音频采集阶段                           │
├─────────────────────────────────────────────────────────────┤
│  • 3个麦克风同步采样 (50 kHz)                                │
│  • DMA传输到环形缓冲区                                       │
│  • 检测声音活动（能量阈值）                                   │
└─────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────┐
│                     2. 预处理阶段                            │
├─────────────────────────────────────────────────────────────┤
│  • 归一化到满量程                                            │
│  • 应用 DPSS 窗函数 (减少频谱泄漏)                            │
│  • 代码位置: sample_compute.h:109-117                        │
└─────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────┐
│                     3. 互相关计算                            │
├─────────────────────────────────────────────────────────────┤
│  • 计算三对麦克风: (A,B), (A,C), (B,C)                       │
│  • 得到每个延迟值的相似度得分                                 │
│  • 找出最佳延迟                                              │
│  • 代码位置: correlations.c:9-24                            │
└─────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────┐
│                     4. 时间平均                              │
├─────────────────────────────────────────────────────────────┤
│  • 新旧结果指数加权平均 (τ = 0.5s)                          │
│  • 减少噪声影响                                              │
│  • 代码位置: correlations.c:38-63                           │
└─────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────┐
│                     5. 位置评分                              │
├─────────────────────────────────────────────────────────────┤
│  • 遍历热图网格上的每个点                                    │
│  • 计算每个点的理论时间延迟                                  │
│  • 从互相关结果中查找对应得分                                │
│  • 累加三对麦克风的得分作为总分                              │
│  • 代码位置: vga_heatmap.h:99-107                           │
└─────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────┐
│                     6. 热图显示                              │
├─────────────────────────────────────────────────────────────┤
│  • 根据总分分配颜色 (白>绿>红>蓝>黑)                        │
│  • VGA 实时渲染                                              │
│  • 标注麦克风位置                                            │
│  • 代码位置: vga_heatmap.h:116-135                          │
└─────────────────────────────────────────────────────────────┘
```

### 数据流图

```
麦克风 A ──┐
           ├──→ [互相关] ──→ [时间平均] ──→ [热图评分] ──→ [VGA显示]
麦克风 B ──┤
           │
麦克风 C ──┘
```

---

## 关键代码实现

### 1. 互相关计算

**文件：** [src/components/correlations.c](src/components/correlations.c)

```c
// 遍历所有可能的延迟偏移
for (int s = -MAX_SHIFT_SAMPLES; s <= MAX_SHIFT_SAMPLES; s++) {
  power_t score = 0;

  // 根据偏移调整信号位置
  const sample_t *p = (s < 0 ? buf_a->buffer - s : buf_a->buffer);
  const sample_t *q = (s < 0 ? buf_b->buffer : buf_b->buffer + s);
  int n = BUFFER_SIZE - (s < 0 ? -s : s);

  // 逐点相乘求和
  for (int i = 0; i < n; i++, p++, q++)
    score += (int32_t)(*p) * (int32_t)(*q);

  corr->correlations[s + MAX_SHIFT_SAMPLES] = score;

  // 记录最佳延迟
  if (score > best_score) {
    best_score = score;
    corr->best_shift = s;
  }
}
```

### 2. 指数移动平均

**文件：** [src/components/correlations.c](src/components/correlations.c)

```c
void correlations_average(struct correlations_t *estimate,
                          struct correlations_t *new_data) {
  float dt = (now_us - estimate->last_update) / 1e6f;
  float decay = 1.f - exp(-dt / 0.5f);  // 时间常数 0.5秒

  for (int i = 0; i < CORRELATION_BUFFER_SIZE; i++) {
    power_t est = estimate->correlations[i];
    power_t new = new_data->correlations[i];

    // 新旧数据加权融合
    estimate->correlations[i] += (new - est) * decay;
  }
}
```

### 3. 麦克风几何配置

**文件：** [src/components/microphones.c](src/components/microphones.c)

```c
// 使用余弦定理构建三角形
float dAB = MIC_DIST_AB_M;  // A-B 距离
float dBC = MIC_DIST_BC_M;  // B-C 距离
float dCA = MIC_DIST_CA_M;  // C-A 距离

// 计算点 C 的坐标
float xC = (dAB * dAB + dCA * dCA - dBC * dBC) / (2.0f * dAB);
float yC = sqrtf(fmaxf(0.0f, dCA * dCA - xC * xC));

// 移到中心，旋转对齐
// ... (见完整代码)
```

---

## 性能参数

### 硬件配置

| 参数 | 值 | 说明 |
|------|-----|------|
| 微控制器 | Raspberry Pi Pico (RP2040) | 双核 ARM Cortex-M0+ |
| 时钟频率 | 250 MHz | 超频模式 |
| 麦克风数量 | 3 | ADC 通道 0, 1, 2 |
| 采样率 | 50,000 Hz | 每秒 50,000 个样本 |

### 音频参数

| 参数 | 值 | 说明 |
|------|-----|------|
| 缓冲区大小 | 256 样本 | [constants.h](src/components/constants.h) |
| 窗函数 | DPSS (离散扁长椭球序列) | [window.ipynb](window.ipynb) |
| 最大延迟 | ±46 样本 | 约 ±32 cm 距离差 |

### 几何参数

| 参数 | 值 | 说明 |
|------|-----|------|
| A-B 距离 | 13.2 cm | [constants.h:17](src/components/constants.h#L17) |
| B-C 距离 | 15.0 cm | [constants.h:18](src/components/constants.h#L18) |
| C-A 距离 | 20.0 cm | [constants.h:19](src/components/constants.h#L19) |
| 声速 | 343 m/s | 常温下 |

### 时间/距离分辨率

| 指标 | 值 | 计算公式 |
|------|-----|----------|
| 时间分辨率 | 20 μs | 1 / 50,000 Hz |
| 距离分辨率 | 6.86 mm | 343 / 50,000 m |
| 最大距离差 | ±31.6 cm | 46 × 6.86 mm |

### 实时性能

| 指标 | 值 |
|------|-----|
| 处理延迟 | ~5 ms (一个缓冲区) |
| 刷新率 | 取决于声音活动检测 |
| 时间常数 | 0.5 秒 (指数平滑) |

---

## 数学公式汇总

### 双曲线定义

```
|PF₁ - PF₂| = 2a

其中：
- P = 双曲线上任意一点
- F₁, F₂ = 两个焦点（麦克风位置）
- 2a = 距离差的绝对值
```

### 互相关函数

```
R_xy[k] = Σ x[n] · y[n + k]
         n

其中：
- k = 时间偏移（样本数）
- R_xy[k] = 延迟为 k 时的相似度
```

### 距离差与时间延迟

```
Δd = c · Δt
Δt = s / fs

其中：
- Δd = 距离差（米）
- c = 声速（343 m/s）
- Δt = 时间延迟（秒）
- s = 样本偏移
- fs = 采样率（50,000 Hz）
```

### 位置评分

```
L(x,y) = R_AB[s_ab(x,y)] + R_AC[s_ac(x,y)] + R_BC[s_bc(x,y)]

其中：
- (x,y) = 候选位置
- s_ab(x,y) = 该位置的理论延迟（A-B）
- R_AB[s] = 实测互相关值
```

### 指数移动平均

```
y[n] = y[n-1] + α · (x[n] - y[n-1])
α = 1 - e^(-Δt/τ)

其中：
- y[n] = 当前估计值
- x[n] = 新测量值
- α = 衰减因子
- τ = 时间常数（0.5 秒）
```

---

## 应用场景

本声音定位系统适用于：

1. **声源追踪**：实时定位并跟踪移动物体（如无人机、机器人）
2. **会议系统**：自动识别发言者位置，控制摄像头方向
3. **安防监控**：检测异常声音（爆炸、枪声）并定位源头
4. **工业监测**：定位设备故障产生的异响
5. **人机交互**：手势识别、语音控制增强

---

## 扩展与改进

### 可能的改进方向

1. **更多麦克风**：增加麦克风数量可提高精度和抗干扰能力
2. **自适应阵列**：动态调整麦克风位置以优化特定区域的精度
3. **频域分析**：结合 FFT 进行频率特征提取，区分不同声源
4. **机器学习**：使用神经网络进行声源分类和定位
5. **3D 定位**：添加垂直方向的麦克风，实现三维定位

### 精度限制因素

| 因素 | 影响 | 改进方法 |
|------|------|----------|
| 采样率 | 决定时间分辨率 | 提高采样率 |
| 麦克风间距 | 影响基线长度 | 优化几何配置 |
| 噪声 | 降低互相关峰值 | 滤波、平均 |
| 混响 | 造成虚假峰值 | 去混响算法 |
| 量化误差 | ADC 精度限制 | 使用更高位数 ADC |

---

## 参考代码位置

| 功能模块 | 文件路径 | 关键函数/行号 |
|----------|----------|---------------|
| 互相关计算 | [src/components/correlations.c](src/components/correlations.c) | `correlations_init()` |
| 时间平均 | [src/components/correlations.c](src/components/correlations.c) | `correlations_average()` |
| 热图初始化 | [src/components/vga/vga_heatmap.h](src/components/vga/vga_heatmap.h) | `vga_init_heatmap()` |
| 热图绘制 | [src/components/vga/vga_heatmap.h](src/components/vga/vga_heatmap.h) | `vga_draw_heatmap()` |
| 麦克风几何 | [src/components/microphones.c](src/components/microphones.c) | `microphones_init()` |
| 主控制逻辑 | [src/sample_compute.h](src/sample_compute.h) | `protothread_sample_and_compute()` |
| 常量定义 | [src/components/constants.h](src/components/constants.h) | 全部 |

---

## 总结

本声音定位系统通过以下技术实现高精度实时定位：

1. **TDOA 原理**：利用声音到达不同麦克风的时间差进行定位
2. **双曲线几何**：时间差对应距离差，构成双曲线约束
3. **互相关算法**：精确测量两个信号的时间延迟
4. **网格搜索**：遍历所有可能位置，找出最符合实测数据的位置
5. **实时处理**：在资源受限的嵌入式设备上实现高性能计算

该系统展示了信号处理、几何计算和实时系统的完美结合，在工程应用中具有广阔前景。

---

**文档版本：** 1.0
**最后更新：** 2025-01-29
**作者：** Audio Triangulation Team
